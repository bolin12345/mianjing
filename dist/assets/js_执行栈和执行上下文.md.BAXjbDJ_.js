import{_ as a,c as e,o as t,a1 as i}from"./chunks/framework.OzTm07G-.js";const m=JSON.parse('{"title":"执行栈和执行上下文","description":"","frontmatter":{},"headers":[],"relativePath":"js/执行栈和执行上下文.md","filePath":"js/执行栈和执行上下文.md"}'),l={name:"js/执行栈和执行上下文.md"},r=i('<h1 id="执行栈和执行上下文" tabindex="-1">执行栈和执行上下文 <a class="header-anchor" href="#执行栈和执行上下文" aria-label="Permalink to &quot;执行栈和执行上下文&quot;">​</a></h1><h2 id="javascript-中的执行环境" tabindex="-1">JavaScript 中的执行环境 <a class="header-anchor" href="#javascript-中的执行环境" aria-label="Permalink to &quot;JavaScript 中的执行环境&quot;">​</a></h2><ol><li>全局环境</li><li>函数环境</li><li>eval 函数环境（已不推荐使用） 函数会将传入的字符串当做 JavaScript 代码进行执行。</li></ol><p>与之对应的执行上下文类型：</p><ol><li>全局上下文</li><li>函数上下文</li><li>eval 函数执行上下文</li></ol><p>javaScript 运行时首先会进入全局环境，对应会生成全局上下文，程序代码中基本都会存在函数，那么调用函数就会进入函数执行环境，对应就会生成函数执行上下文<br> 由于代码中会声明多个函数，对应的函数执行上下文也会存在多个，在js中，通过栈存取方式来管理执行上下文，我们可称其为可执行栈，或函数调用栈</p><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><p>栈遵循“先进后出，后进先出”的规则，称为LIFO（Last In First Out）规则</p><ol><li>后进先出，先进后出</li><li>出口在顶部，且仅有一个</li></ol><h4 id="执行上下文的数量限制-堆栈溢出" tabindex="-1">执行上下文的数量限制（堆栈溢出） <a class="header-anchor" href="#执行上下文的数量限制-堆栈溢出" aria-label="Permalink to &quot;执行上下文的数量限制（堆栈溢出）&quot;">​</a></h4><p>执行上下文可存在多个，但是如果超出了栈分配的空间，就会造成堆栈溢出，常见与递归调用，没有终止条件造成死循环</p>',11),o=[r];function s(_,c,n,h,d,p){return t(),e("div",null,o)}const f=a(l,[["render",s]]);export{m as __pageData,f as default};
